################################################################################
## _retrievers/azure_search_retriever.py
## Copyright (c) 2025 Jeff Teeter, Ph.D.
## Cisco Systems, Inc.
## Licensed under the Apache License, Version 2.0 (see LICENSE)
## Distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND.
################################################################################

import os
import logging
import requests
import json
import re
from typing import List, Dict, Optional
from dotenv import load_dotenv

load_dotenv()

def sanitize_filename(s: str, max_length=100) -> str:
    """
    Removes invalid characters from a string for filenames, then trims
    it to 'max_length' characters to avoid overly long filenames.
    """
    # Replace invalid characters with '_'
    s = re.sub(r'[\\/:*?"<>|]', '_', s)
    # Trim to max_length; also remove trailing spaces
    return s[:max_length].rstrip()

class AzureSearchRetriever:
    """
    This class encapsulates logic to retrieve documents from Azure Cognitive Search
    using embeddings generated by Azure OpenAI, for the 2023-11-01 or 2024-11-01-preview API versions.

    Key points for 2024-11-01-preview usage:
      - queryType: "semantic"
      - 'vectorQueries' (with kind="vector", fields=..., vector=..., k=...)
      - 'select': comma-delimited list of fields
      - Must POST to /docs/search?api-version=2024-11-01-preview
    """

    def __init__(self):
        # Azure Search settings
        self.search_service = os.getenv("AZURE_SEARCH_SERVICE", "")
        self.search_key = os.getenv("AZURE_SEARCH_KEY", "")
        self.search_endpoint = os.getenv("AZURE_SEARCH_ENDPOINT", "")
        self.domain_index = os.getenv("AZURE_SEARCH_DOMAIN_INDEX", "")
        self.api_docs_index = os.getenv("AZURE_SEARCH_API_DOCS_INDEX", "")
        self.events_index = os.getenv("AZURE_SEARCH_EVENTS_INDEX", "")

        # Generic LOB index (e.g. lob-healthcare)
        self.lob_index = os.getenv("AZURE_SEARCH_LOB_INDEX", "")

        # Typically "2024-11-01-preview" if matching your working curl calls
        self.search_api_version = os.getenv("AZURE_SEARCH_API_VERSION", "2024-11-01-preview")

        # Azure OpenAI (Embedding) settings
        self.embedding_deployment = os.getenv("AZURE_OPENAI_EMBEDDING_DEPLOYMENT", "")
        self.openai_api_version = os.getenv("AZURE_OPENAI_API_VERSION", "2023-05-15")
        self.openai_endpoint = os.getenv("AZURE_OPENAI_ENDPOINT", "")
        self.openai_key = os.getenv("AZURE_OPENAI_KEY", "")

        # Where embeddings are stored in the index (usually "embedding")
        self.vector_columns = os.getenv("AZURE_SEARCH_VECTOR_COLUMNS", "embedding")
        self.top_k = int(os.getenv("AZURE_SEARCH_TOP_K", "5"))
        self.safe_query = ""

        if not self.search_endpoint and self.search_service:
            self.search_endpoint = f"https://{self.search_service}.search.windows.net"

        logging.info(f"Azure Search Service: {self.search_service}")
        logging.info(f"Azure Search Endpoint: {self.search_endpoint}")
        logging.info(f"Domain Index: {self.domain_index}")
        logging.info(f"API Docs Index: {self.api_docs_index}")
        logging.info(f"Events Index: {self.events_index}")
        logging.info(f"LOB Index: {self.lob_index}")
        logging.info(f"Embedding Deployment: {self.embedding_deployment}")
        logging.info(f"OpenAI API Version: {self.openai_api_version}")
        logging.info(f"Search API Version: {self.search_api_version}")
        logging.info(f"Top K: {self.top_k}")

    def generate_embedding(self, user_input: str) -> List[float]:
        """
        Generate embeddings for the given user input using Azure OpenAI (text-embedding).
        """
        try:
            url = (
                f"{self.openai_endpoint}/openai/deployments/{self.embedding_deployment}"
                f"/embeddings?api-version={self.openai_api_version}"
            )
            headers = {
                "Content-Type": "application/json",
                "api-key": self.openai_key
            }
            payload = {"input": [user_input]}

            response = requests.post(url, headers=headers, json=payload)
            response.raise_for_status()

            data = response.json()
            embedding_vector = data["data"][0]["embedding"]
            logging.info(f"Generated embedding vector of length {len(embedding_vector)}.")

            # Create a safe filename for the embedding
            self.safe_query = sanitize_filename(user_input)

            # Ensure an "embeddings" directory exists
            output_dir = "embeddings"
            os.makedirs(output_dir, exist_ok=True)

            # Construct a final file path
            file_path = os.path.join(output_dir, f"embedding_{self.safe_query}.json")

            # Write to disk
            with open(file_path, "w") as f:
                json.dump({"query": user_input, "embedding": embedding_vector}, f, indent=4)
            logging.info(f"Saved embedding to {file_path}")

            return embedding_vector

        except requests.exceptions.RequestException as e:
            logging.error(f"Error generating embeddings: {e}")
            raise

    def query_index(self, index_name: str, payload: Dict) -> List[Dict[str, str]]:
        """
        POST to /indexes('<index_name>')/docs/search?api-version=...
        with the given payload, returning docs (list of dict).
        """
        try:
            url = (
                f"{self.search_endpoint}/indexes('{index_name}')/docs/search"
                f"?api-version={self.search_api_version}"
            )
            headers = {
                "Content-Type": "application/json",
                "api-key": self.search_key
            }
            logging.debug(f"Serialized Payload: {json.dumps(payload)}")
            logging.info(f"Querying index {index_name} with payload: {payload}")

            resp = requests.post(url, headers=headers, json=payload)
            resp.raise_for_status()

            results = resp.json()
            docs = results.get("value", [])
            logging.info(f"Retrieved {len(docs)} documents from {index_name}.")

            # Example: If event_id present, prepend it to content
            for doc in docs:
                if "event_id" in doc and "content" in doc:
                    doc["content"] = f"Event ID: {doc['event_id']}\n{doc['content']}"

            return docs

        except requests.exceptions.RequestException as e:
            logging.error(f"Error querying Azure Search '{index_name}': {e}")
            if e.response is not None:
                logging.error(f"Response content: {e.response.content.decode('utf-8')}")
            return []

    # --------------------------
    # Domain Summaries
    # --------------------------
    def retrieve_domain_info(self, query: str) -> List[Dict[str, str]]:
        embedding_vector = self.generate_embedding(query)
        payload = {
            "search": query,
            "queryType": "semantic",
            "semanticConfiguration": "mySummariesSemanticConfig",
            "top": self.top_k,
            "vectorQueries": [
                {
                    "kind": "vector",
                    "fields": self.vector_columns,
                    "vector": embedding_vector,
                    "k": self.top_k
                }
            ],
            "select": "title,content,platform,doc_type"
        }
        return self.query_index(self.domain_index, payload)

    # --------------------------
    # API Docs
    # --------------------------
    def retrieve_api_docs(self, query: str, platforms: List[str]) -> List[Dict[str, str]]:
        embedding_vector = self.generate_embedding(query)
        logging.info(f"Embedding vector for query '{query}': {embedding_vector}")

        payload = {
            "search": query,
            "queryType": "semantic",
            "semanticConfiguration": "myApiDocsSemanticConfig",
            "top": self.top_k,
            "vectorQueries": [
                {
                    "kind": "vector",
                    "fields": self.vector_columns,
                    "vector": embedding_vector,
                    "k": self.top_k
                }
            ],
            "select": "title,content,platform,doc_type"
        }

        if platforms:
            filter_clause = " or ".join([f"platform eq '{p}'" for p in platforms])
            payload["filter"] = filter_clause

        return self.query_index(self.api_docs_index, payload)

    # --------------------------
    # Events
    # --------------------------
    def retrieve_event_info(self, query: str, event_type: Optional[str] = None) -> List[Dict[str, str]]:
        embedding_vector = self.generate_embedding(query)
        logging.info(f"Embedding vector for query '{query}': {embedding_vector}")

        payload = {
            "search": query,
            "queryType": "semantic",
            "semanticConfiguration": "myEventsSemanticConfig",
            "top": self.top_k,
            "vectorQueries": [
                {
                    "kind": "vector",
                    "fields": self.vector_columns,
                    "vector": embedding_vector,
                    "k": self.top_k
                }
            ],
            "select": "event_id,event_name,event_type,content,additional_info"
        }

        if event_type:
            payload["filter"] = f"event_type eq '{event_type}'"

        return self.query_index(self.events_index, payload)

    def retrieve_event_info_semantic_advanced(
        self,
        query: str,
        event_type: Optional[str] = None,
        top: int = 7,
        filter_clause: Optional[str] = None,
        facets: Optional[List[str]] = None,
        exhaustive: bool = True,
    ) -> List[Dict[str, str]]:
        embedding_vector = self.generate_embedding(query)
        logging.info(f"Embedding vector for query '{query}': {embedding_vector}")

        if event_type:
            extra_clause = f"event_type eq '{event_type}'"
            if filter_clause:
                filter_clause = f"({filter_clause}) and ({extra_clause})"
            else:
                filter_clause = extra_clause

        payload = {
            "count": True,
            "search": query,
            "queryType": "semantic",
            "semanticConfiguration": "myEventsSemanticConfig",
            "top": top,
            "select": "event_id,event_name,event_type,content,additional_info",
            "vectorQueries": [
                {
                    "kind": "vector",
                    "fields": self.vector_columns,
                    "vector": embedding_vector,
                    "k": top,
                    "exhaustive": exhaustive
                }
            ]
        }

        if filter_clause:
            payload["filter"] = filter_clause
        if facets:
            payload["facets"] = facets

        return self.query_index(self.events_index, payload)

    # --------------------------
    # LOB (Generic)
    # --------------------------
    def retrieve_lob_info(self, query: str) -> List[Dict[str, str]]:
        """
        Retrieves data from the LOB index (e.g., 'lob-healthcare')
        using semantic + vector search. 
        Our final schema fields are: id, content, embedding, metadata.

        If you want a different semantic config name for each LOB index,
        you could do: semantic_config = f"{self.lob_index}-semantic-config"
        Instead of a hard-coded 'lob-healthcare-semantic-config'.
        """
        embedding_vector = self.generate_embedding(query)
        # optional: build config name from the lob_index
        semantic_config = f"{self.lob_index}-semantic-config"

        payload = {
            "search": query,
            "queryType": "semantic",
            "semanticConfiguration": semantic_config,
            "top": self.top_k,
            "vectorQueries": [
                {
                    "kind": "vector",
                    "fields": self.vector_columns,  # "embedding"
                    "vector": embedding_vector,
                    "k": self.top_k
                }
            ],
            # Retrieve id, content, metadata. embedding is non-retrievable
            "select": "id,content,metadata"
        }
        return self.query_index(self.lob_index, payload)


# Example usage (local testing)
if __name__ == "__main__":
    retriever = AzureSearchRetriever()

    # For advanced event usage
    query_text = "boundary crossing events on floor 4"
    advanced_results = retriever.retrieve_event_info_semantic_advanced(
        query=query_text,
        event_type=None,
        top=7,
        filter_clause=None,
        facets=["additional_info/building"],
        exhaustive=True
    )
    print("ADVANCED SEMANTIC HYBRID RESULTS:")
    for doc in advanced_results:
        print(doc)

    # Quick event usage
    print("\n---\nNow let's do simpler calls:\n")
    print("Retrieving Event Info (no event_type filter):")
    event_results = retriever.retrieve_event_info("Look for relevant events")
    for doc in event_results:
        print(doc)

    # Example LOB usage
    # Ensure AZURE_SEARCH_LOB_INDEX=lob-healthcare is set in your .env
    print("\n---\nNow let's do LOB retrieval:\n")
    lob_results = retriever.retrieve_lob_info("Which patients have an appointment on Feb 5?")
    for doc in lob_results:
        print(doc)

    print("\nAll retrieval tasks completed.")
